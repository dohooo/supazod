import { readFileSync, unlinkSync, existsSync } from 'node:fs';
import { join } from 'node:path';
import { fileURLToPath } from 'url';
import { describe, expect, it, afterEach } from 'vitest';

import { generateContent, supabaseToZodOptionsSchema } from './supabase-to-zod';

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const EXAMPLE_DIR = join(__dirname, '../example');

describe('supazod', () => {
  it('should generate schemas with specific schema names matching the example output', async () => {
    const typesFilePath = join(EXAMPLE_DIR, 'types.ts');
    const opts = supabaseToZodOptionsSchema.parse({
      input: typesFilePath,
      output: join(EXAMPLE_DIR, 'schema.ts'),
      typesOutput: join(EXAMPLE_DIR, 'schema.d.ts'),
      schema: ['public'],
      verbose: false,
    });

    const result = await generateContent(opts);

    expect(readFileSync(typesFilePath, 'utf-8')).toMatchInlineSnapshot(`
      "export type Json =
        | string
        | number
        | boolean
        | null
        | { [key: string]: Json }
        | Json[];

      export type Database = {
        public: {
          Tables: {
            users: {
              Row: {
                username: string;
                data: Json | null;
                age_range: unknown | null;
                catchphrase: unknown | null;
                status: Database['public']['Enums']['user_status'] | null;
                platform: Database["public"]["Enums"]["provider_slug"]
              };
              Insert: {
                username: string;
                data?: Json | null;
                age_range?: unknown | null;
                catchphrase?: unknown | null;
                status?: Database['public']['Enums']['user_status'] | null;
              };
              Update: {
                username?: string;
                data?: Json | null;
                age_range?: unknown | null;
                catchphrase?: unknown | null;
                status?: Database['public']['Enums']['user_status'] | null;
              };
              Relationships: [];
            };
          };
          Views: {
            non_updatable_view: {
              Row: {
                username: string | null;
              };
            };
          };
          Functions: {
            get_status: {
              Args: { name_param: string };
              Returns: Database['public']['Enums']['user_status'];
            };
          };
          Enums: {
            user_status: 'ONLINE' | 'OFFLINE';
            provider_slug:
              | "github"
              | "slack"
              | "discord"
              | "web"
              | "linear"
              | "jira"
              | "memory"
              | "dosu_app"
          };
        };
        schema_b: {
          Tables: {
            users: {
              Row: {
                username: string;
                data: Json | null;
                status: Database['public']['Enums']['user_status'] | null;
              };
              Insert: {
                username: string;
                age_range?: unknown | null;
                catchphrase?: unknown | null;
                status?: Database['schema_b']['Enums']['user_status'] | null;
              };
              Update: {
                data?: Json | null;
                age_range?: unknown | null;
                catchphrase?: unknown | null;
                status?: Database['schema_b']['Enums']['user_status'] | null;
              };
            };
          };
          Views: {
            non_updatable_view: {
              Row: {
                username: string | null;
              };
            };
          };
          Functions: {
            get_deployment_config_schema: {
              Args: Record<PropertyKey, never>;
              Returns: Json;
            };
            get_status: {
              Args: { name_param: string };
              Returns: Database['schema_b']['Enums']['user_status'];
            };
          };
          Enums: {
            user_status: 'ONLINE' | 'OFFLINE';
          };
        };
      }
      "
    `);

    expect(result?.rawSchemasFileContent).toMatchInlineSnapshot(`
      "/*
       * ==========================================
       * |          GENERATED BY SUPAZOD          |
       * ==========================================
       */

      import { z } from "zod";
      import { type Json } from "./types";

      export const publicProviderSlugSchema = z.union([z.literal("github"), z.literal("slack"), z.literal("discord"), z.literal("web"), z.literal("linear"), z.literal("jira"), z.literal("memory"), z.literal("dosu_app")]);

      export const jsonSchema: z.ZodSchema<Json> = z.lazy(() => z.union([z.string(), z.number(), z.boolean(), z.record(jsonSchema), z.array(jsonSchema)]).nullable());

      export const publicUserStatusSchema = z.union([z.literal("ONLINE"), z.literal("OFFLINE")]);

      export const publicUsersInsertSchemaSchema = z.object({
          username: z.string(),
          data: jsonSchema.optional().nullable(),
          age_range: z.unknown().optional().nullable(),
          catchphrase: z.unknown().optional().nullable(),
          status: publicUserStatusSchema.optional().nullable()
      });

      export const publicUsersUpdateSchemaSchema = z.object({
          username: z.string().optional(),
          data: jsonSchema.optional().nullable(),
          age_range: z.unknown().optional().nullable(),
          catchphrase: z.unknown().optional().nullable(),
          status: publicUserStatusSchema.optional().nullable()
      });

      export const publicNonUpdatableViewRowSchemaSchema = z.object({
          username: z.string().nullable()
      });

      export const publicGetStatusArgsSchemaSchema = z.object({
          name_param: z.string()
      });

      export const publicGetStatusReturnsSchemaSchema = publicUserStatusSchema;

      export const schemaBUserStatusSchema = z.union([z.literal("ONLINE"), z.literal("OFFLINE")]);

      export const publicUsersRowSchemaSchema = z.object({
          username: z.string(),
          data: jsonSchema.nullable(),
          age_range: z.unknown().nullable(),
          catchphrase: z.unknown().nullable(),
          status: publicUserStatusSchema.nullable(),
          platform: publicProviderSlugSchema
      });
      "
    `);

    expect(result?.rawTypesFileContent).toMatchInlineSnapshot(`
      "/*
       * ==========================================
       * |          GENERATED BY SUPAZOD          |
       * ==========================================
       */

      import { z } from "zod";
      import * as generated from "./../../../../../../example/schema";
      export type PublicProviderSlug = z.infer<typeof generated.publicProviderSlugSchema>;
      export type Json = z.infer<typeof generated.jsonSchema>;
      export type PublicUserStatus = z.infer<typeof generated.publicUserStatusSchema>;
      export type PublicUsersInsertSchema = z.infer<typeof generated.publicUsersInsertSchemaSchema>;
      export type PublicUsersUpdateSchema = z.infer<typeof generated.publicUsersUpdateSchemaSchema>;
      export type PublicNonUpdatableViewRowSchema = z.infer<typeof generated.publicNonUpdatableViewRowSchemaSchema>;
      export type PublicGetStatusArgsSchema = z.infer<typeof generated.publicGetStatusArgsSchemaSchema>;
      export type PublicGetStatusReturnsSchema = z.infer<typeof generated.publicGetStatusReturnsSchemaSchema>;
      export type SchemaBUserStatus = z.infer<typeof generated.schemaBUserStatusSchema>;
      export type PublicUsersRowSchema = z.infer<typeof generated.publicUsersRowSchemaSchema>;
      "
    `);
  });

  it('should generate schemas with default schema names(all schemas) matching the example output', async () => {
    const typesFilePath = join(EXAMPLE_DIR, 'types.ts');
    const opts = supabaseToZodOptionsSchema.parse({
      input: typesFilePath,
      output: join(EXAMPLE_DIR, 'schema.ts'),
      typesOutput: join(EXAMPLE_DIR, 'schema.d.ts'),
      schema: [],
      verbose: false,
    });

    const result = await generateContent(opts);

    expect(readFileSync(typesFilePath, 'utf-8')).toMatchInlineSnapshot(`
      "export type Json =
        | string
        | number
        | boolean
        | null
        | { [key: string]: Json }
        | Json[];

      export type Database = {
        public: {
          Tables: {
            users: {
              Row: {
                username: string;
                data: Json | null;
                age_range: unknown | null;
                catchphrase: unknown | null;
                status: Database['public']['Enums']['user_status'] | null;
                platform: Database["public"]["Enums"]["provider_slug"]
              };
              Insert: {
                username: string;
                data?: Json | null;
                age_range?: unknown | null;
                catchphrase?: unknown | null;
                status?: Database['public']['Enums']['user_status'] | null;
              };
              Update: {
                username?: string;
                data?: Json | null;
                age_range?: unknown | null;
                catchphrase?: unknown | null;
                status?: Database['public']['Enums']['user_status'] | null;
              };
              Relationships: [];
            };
          };
          Views: {
            non_updatable_view: {
              Row: {
                username: string | null;
              };
            };
          };
          Functions: {
            get_status: {
              Args: { name_param: string };
              Returns: Database['public']['Enums']['user_status'];
            };
          };
          Enums: {
            user_status: 'ONLINE' | 'OFFLINE';
            provider_slug:
              | "github"
              | "slack"
              | "discord"
              | "web"
              | "linear"
              | "jira"
              | "memory"
              | "dosu_app"
          };
        };
        schema_b: {
          Tables: {
            users: {
              Row: {
                username: string;
                data: Json | null;
                status: Database['public']['Enums']['user_status'] | null;
              };
              Insert: {
                username: string;
                age_range?: unknown | null;
                catchphrase?: unknown | null;
                status?: Database['schema_b']['Enums']['user_status'] | null;
              };
              Update: {
                data?: Json | null;
                age_range?: unknown | null;
                catchphrase?: unknown | null;
                status?: Database['schema_b']['Enums']['user_status'] | null;
              };
            };
          };
          Views: {
            non_updatable_view: {
              Row: {
                username: string | null;
              };
            };
          };
          Functions: {
            get_deployment_config_schema: {
              Args: Record<PropertyKey, never>;
              Returns: Json;
            };
            get_status: {
              Args: { name_param: string };
              Returns: Database['schema_b']['Enums']['user_status'];
            };
          };
          Enums: {
            user_status: 'ONLINE' | 'OFFLINE';
          };
        };
      }
      "
    `);

    expect(result?.rawSchemasFileContent).toMatchInlineSnapshot(`
      "/*
       * ==========================================
       * |          GENERATED BY SUPAZOD          |
       * ==========================================
       */

      import { z } from "zod";
      import { type Json } from "./types";

      export const publicProviderSlugSchema = z.union([z.literal("github"), z.literal("slack"), z.literal("discord"), z.literal("web"), z.literal("linear"), z.literal("jira"), z.literal("memory"), z.literal("dosu_app")]);

      export const jsonSchema: z.ZodSchema<Json> = z.lazy(() => z.union([z.string(), z.number(), z.boolean(), z.record(jsonSchema), z.array(jsonSchema)]).nullable());

      export const publicUserStatusSchema = z.union([z.literal("ONLINE"), z.literal("OFFLINE")]);

      export const publicUsersInsertSchemaSchema = z.object({
          username: z.string(),
          data: jsonSchema.optional().nullable(),
          age_range: z.unknown().optional().nullable(),
          catchphrase: z.unknown().optional().nullable(),
          status: publicUserStatusSchema.optional().nullable()
      });

      export const publicUsersUpdateSchemaSchema = z.object({
          username: z.string().optional(),
          data: jsonSchema.optional().nullable(),
          age_range: z.unknown().optional().nullable(),
          catchphrase: z.unknown().optional().nullable(),
          status: publicUserStatusSchema.optional().nullable()
      });

      export const publicNonUpdatableViewRowSchemaSchema = z.object({
          username: z.string().nullable()
      });

      export const publicGetStatusArgsSchemaSchema = z.object({
          name_param: z.string()
      });

      export const publicGetStatusReturnsSchemaSchema = publicUserStatusSchema;

      export const schemaBUserStatusSchema = z.union([z.literal("ONLINE"), z.literal("OFFLINE")]);

      export const schemaBUsersRowSchemaSchema = z.object({
          username: z.string(),
          data: jsonSchema.nullable(),
          status: publicUserStatusSchema.nullable()
      });

      export const schemaBUsersInsertSchemaSchema = z.object({
          username: z.string(),
          age_range: z.unknown().optional().nullable(),
          catchphrase: z.unknown().optional().nullable(),
          status: schemaBUserStatusSchema.optional().nullable()
      });

      export const schemaBUsersUpdateSchemaSchema = z.object({
          data: jsonSchema.optional().nullable(),
          age_range: z.unknown().optional().nullable(),
          catchphrase: z.unknown().optional().nullable(),
          status: schemaBUserStatusSchema.optional().nullable()
      });

      export const schemaBNonUpdatableViewRowSchemaSchema = z.object({
          username: z.string().nullable()
      });

      export const schemaBGetDeploymentConfigSchemaArgsSchemaSchema = z.object({});

      export const schemaBGetDeploymentConfigSchemaReturnsSchemaSchema = jsonSchema;

      export const schemaBGetStatusArgsSchemaSchema = z.object({
          name_param: z.string()
      });

      export const schemaBGetStatusReturnsSchemaSchema = schemaBUserStatusSchema;

      export const publicUsersRowSchemaSchema = z.object({
          username: z.string(),
          data: jsonSchema.nullable(),
          age_range: z.unknown().nullable(),
          catchphrase: z.unknown().nullable(),
          status: publicUserStatusSchema.nullable(),
          platform: publicProviderSlugSchema
      });
      "
    `);

    expect(result?.rawTypesFileContent).toMatchInlineSnapshot(`
      "/*
       * ==========================================
       * |          GENERATED BY SUPAZOD          |
       * ==========================================
       */

      import { z } from "zod";
      import * as generated from "./../../../../../../example/schema";
      export type PublicProviderSlug = z.infer<typeof generated.publicProviderSlugSchema>;
      export type Json = z.infer<typeof generated.jsonSchema>;
      export type PublicUserStatus = z.infer<typeof generated.publicUserStatusSchema>;
      export type PublicUsersInsertSchema = z.infer<typeof generated.publicUsersInsertSchemaSchema>;
      export type PublicUsersUpdateSchema = z.infer<typeof generated.publicUsersUpdateSchemaSchema>;
      export type PublicNonUpdatableViewRowSchema = z.infer<typeof generated.publicNonUpdatableViewRowSchemaSchema>;
      export type PublicGetStatusArgsSchema = z.infer<typeof generated.publicGetStatusArgsSchemaSchema>;
      export type PublicGetStatusReturnsSchema = z.infer<typeof generated.publicGetStatusReturnsSchemaSchema>;
      export type SchemaBUserStatus = z.infer<typeof generated.schemaBUserStatusSchema>;
      export type SchemaBUsersRowSchema = z.infer<typeof generated.schemaBUsersRowSchemaSchema>;
      export type SchemaBUsersInsertSchema = z.infer<typeof generated.schemaBUsersInsertSchemaSchema>;
      export type SchemaBUsersUpdateSchema = z.infer<typeof generated.schemaBUsersUpdateSchemaSchema>;
      export type SchemaBNonUpdatableViewRowSchema = z.infer<typeof generated.schemaBNonUpdatableViewRowSchemaSchema>;
      export type SchemaBGetDeploymentConfigSchemaArgsSchema = z.infer<typeof generated.schemaBGetDeploymentConfigSchemaArgsSchemaSchema>;
      export type SchemaBGetDeploymentConfigSchemaReturnsSchema = z.infer<typeof generated.schemaBGetDeploymentConfigSchemaReturnsSchemaSchema>;
      export type SchemaBGetStatusArgsSchema = z.infer<typeof generated.schemaBGetStatusArgsSchemaSchema>;
      export type SchemaBGetStatusReturnsSchema = z.infer<typeof generated.schemaBGetStatusReturnsSchemaSchema>;
      export type PublicUsersRowSchema = z.infer<typeof generated.publicUsersRowSchemaSchema>;
      "
    `);
  });

  it('should append types to the schema file by default', async () => {
    const typesFilePath = join(EXAMPLE_DIR, 'types.ts');
    const outputPath = join(EXAMPLE_DIR, 'schema-with-types-default.ts');
    const opts = supabaseToZodOptionsSchema.parse({
      input: typesFilePath,
      output: outputPath,
      schema: ['public'],
      verbose: false,
    });

    const result = await generateContent(opts);
    const combinedContent = `${result?.formatterSchemasFileContent}\n\n// ---- Inferred Types ----\n\n${result?.formatterTypesFileContent}`;

    expect(combinedContent).toContain('// ---- Inferred Types ----');
    expect(combinedContent).toContain('export type');
    expect(combinedContent).toContain('export const');
    expect(
      combinedContent
        .trim()
        .endsWith(result?.formatterTypesFileContent.trim() || 'types'),
    ).toBe(true);
  });

  it('should write types to typesOutput if provided and file exists', async () => {
    const typesFilePath = join(EXAMPLE_DIR, 'types.ts');
    const outputPath = join(EXAMPLE_DIR, 'schema-with-types-file.ts');
    const typesOutputPath = join(EXAMPLE_DIR, 'types-output-file.ts');
    // Ensure the file exists
    require('fs').writeFileSync(typesOutputPath, '// dummy file');
    const opts = supabaseToZodOptionsSchema.parse({
      input: typesFilePath,
      output: outputPath,
      typesOutput: typesOutputPath,
      schema: ['public'],
      verbose: false,
    });

    const result = await generateContent(opts);
    // Simulate what would be written to typesOutput
    const typesContent = result?.formatterTypesFileContent;
    expect(typesContent).toContain('export type');
    expect(typesContent).not.toContain('export const'); // types file should not contain schema exports
  });

  it('should use a custom typeNameTransformer function', async () => {
    const typesFilePath = join(EXAMPLE_DIR, 'types.ts');
    // Custom transformer: lowercases all type names
    const customTransformer = (name: string) => name.toLowerCase();
    const opts = supabaseToZodOptionsSchema.parse({
      input: typesFilePath,
      output: join(EXAMPLE_DIR, 'schema.ts'),
      typesOutput: join(EXAMPLE_DIR, 'schema.d.ts'),
      schema: ['public'],
      verbose: false,
      typeNameTransformer: customTransformer,
    });

    const result = await generateContent(opts);
    // Check that at least one type name is lowercased (e.g., publicuserstatus)
    expect(result?.rawTypesFileContent).toContain(
      'export type publicuserstatus',
    );
    // Optionally, check that no PascalCase type names exist
    expect(result?.rawTypesFileContent).not.toMatch(/export type [A-Z][a-z]+/);
  });
});

afterEach(() => {
  const filesToClean = [
    'schema-with-types-default.ts',
    'schema-with-types-file.ts',
    'types-output-file.ts',
  ];
  for (const file of filesToClean) {
    const filePath = join(EXAMPLE_DIR, file);
    if (existsSync(filePath)) {
      try {
        unlinkSync(filePath);
      } catch {}
    }
  }
});
